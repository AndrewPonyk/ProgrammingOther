1) Visualizing branches in Git (in console), what is command alias.	git log --graph --oneline --all --decorate    - nice display of all branches , merges, tags		Create alias for this long command	*	git config --global alias.lga "log --graph --oneline --all --decorate"	and now : 'git lga' =)	-------------------------------------------------------------------2) Creating local branches in Git , differences between branches and tags, describe .	Create local branch :		* git branch feature1    - create 'feature1' branch		* git checkout feature1   - make 'feature1' current branch		(or one command 'git  checkout -b feature1') !			We can also create branch by binding it to commit in past		* git branch fix1 b38d3					! Difference between branch and tag :		The branch follow commits , and tag is binded to one commit;			branch		A "branch" is an active line of development. The most recent commit on a 		branch is referred to as the tip of that branch. The tip of the branch is 		referenced by a branch head, which moves forward as additional development 		is done on the branch. A single git repository can track an arbitrary number of branches,		but your working tree is associated with just one of them (the "current" or "checked out" branch),		and HEAD points to that branch.		tag		A ref pointing to a tag or commit object. In contrast to a head, a tag is not changed by a commit.		Tags (not tag objects) are stored in $GIT_DIR/refs/tags/. [...]. 		A tag is most typically used to mark a particular point in the commit ancestry chain.-------------------------------------------------------------------3) Git rename and remove branches, describe.	To rename branch :		* git branch -m fix1 bug1234       - rename branch 'fix1' to 'bug1234'			To delete branch :		* git branch -d bug1234	-------------------------------------------------------------------4) Git recovering deleted commits , describe.	* git reflog      - shows where HEAD was(and show commits) , so you can recover commits				Reflog is a mechanism to record when the tip of branches are updated. 	This command is to manage the information recorded in it.	The subcommand "expire" is used to prune older reflog entries. Entries 	older than expire time, or entries older than expire-unreachable time and not reachable	from the current tip, are removed from the reflog. This is typically not used directly 	by the end users -- instead, see git-gc(1).	The subcommand "show" (which is also the default, in the absence of any subcommands) 	will take all the normal log options, and show the log of the reference provided in the	command-line (or HEAD, by default). The reflog will cover all recent actions (HEAD reflog	records branch switching as well). It is an alias for git log -g --abbrev-commit --pretty=oneline;	see git-log(1).	The reflog is useful in various Git commands, to specify the old value of a reference. 	For example, HEAD@{2} means "where HEAD used to be two moves ago", master@{one.week.ago} 	means "where master used to point to one week ago", and so on. See gitrevisions(7) for more details.	To delete single entries from the reflog, use the subcommand "delete" and specify the	exact entry (e.g. "git reflog delete master@{2}").	OPTIONS	--stale-fix	This revamps the logic -- the definition of "broken commit" becomes: a commit that is 	not reachable from any of the refs and there is a missing object among the commit, tree, 	or blob objects reachable from it that is not reachable from any of the refs.	This computation involves traversing all the reachable objects, i.e. it has the same cost as	git prune. Fortunately, once this is run, we should not have to ever worry about missing objects,	because the current prune and pack-objects know about reflogs and protect objects referred by them.	--expire=<time>	Entries older than this time are pruned. Without the option it is taken from configuration 	gc.reflogExpire, which in turn defaults to 90 days. --expire=all prunes entries regardless of	their age; --expire=never turns off pruning of reachable entries (but see --expire-unreachable).	--expire-unreachable=<time>	Entries older than this time and not reachable from the current tip of the branch are pruned.	Without the option it is taken from configuration gc.reflogExpireUnreachable, which in turn 	defaults to 30 days. --expire-unreachable=all prunes unreachable entries regardless of their age;	--expire-unreachable=never turns off early pruning of unreachable entries (but see --expire).	--all	Instead of listing <refs> explicitly, prune all refs.	--updateref	Update the ref with the sha1 of the top reflog entry (i.e. <ref>@{0}) after expiring or deleting.	--rewrite	While expiring or deleting, adjust each reflog entry to ensure that the old sha1 field points 	to the new sha1 field of the previous entry.	--verbose	Print extra information on screen.-------------------------------------------------------------------5) STASHING changes in Git , describe  . Git: How to stash with a custom message ?	When you are on branch BRANCH1 , made some changes , and you want to 	checkout BRANCH2 , you cant do this , because you have changes.		YOU have two choices : commit changes OR stash changes , so if you dont want to commit , you will STASH		changes.			Example you are on 'feature2' branch, make some changes in README.txt		* git stash      - stash your changes 			* git stash list  - shows stashed list (you can have one , two or more stash levels		* git checkout feature1   - checkout to feature1 branch		* git checkout feature2  - return to feature2 branch		* git stash pop       - get stashed changes		* git commit -m " Commit stashed changes"					TO get stashed changes we can use 'git apply ' or 'git pop' (i use git pop);		To see what is stashed(levels) use 'git stash list'		To remove last stash level use 'git stash drop'		!!! We can create branch from stashed changes(funny and sometimes usefull) 		* git stash branch feature2_additional		* git commit -m "Commit stashed changes as new branch"				Git: How to stash with a custom message ?	Answer : 'git stash save doing crazy things'-------------------------------------------------------------------6) Git Merging branches , describe. What does it mean 'fast-forward' in Git ? 	What's a “fast-forward” in Git? (fast-forward - in russian 'peremotka' =))		Ultimately, "fast-forward" means that the commits can be applied directly 		on top of the working tree without requiring a merge.			A fast-forward update is where the only changes one one side are after the most recent commit on the 		other side, so there doesn't need to be any merging.		This is saying that you need to merge your changes before you can push.				!Configure git merge tool in windows :		* download kdiff3.exe and install it		* git config --global merge.tool kdiff3.		* and add it to path(Windows)					!!!! To merge two branches (for example master and feature2_additional)	we need:		* git checkout master		* git merge feature2_additional          - you can see that there are merge conflicts		* git mergeetool                  - start your mergetool, you have merge every file with confilt		* git commit -m "Merged two branches"	=)						-------------------------------------------------------------------7) What is 'git rebase' ?	How i UNDERSTAND it :		* for example we have two branches 'master' and 'expreriment'  .		* And i want to set branch 'experiment' ON TOP(rebase) of 'master' , so i will do		* 'git checkout experiment' , 'git rebase master'  (there can be conflicts , you should resolve conflicts and make 'git rebase --continue')		* And after this : 'git checkout master ' , 'git merge experiment' .	=)				How is written in Git documentation :		git-rebase - Forward-port local commits to the updated upstream head	DESCRIPTION	If <branch> is specified, git rebase will perform an automatic git checkout <branch> before 	doing anything else. Otherwise it remains on the current branch.	If <upstream> is not specified, the upstream configured in branch.<name>.remote 	and branch.<name>.merge options will be used; see git-config(1) for details. 	If you are currently not on any branch or if the current branch does not have a configured upstream, 	the rebase will abort.	All changes made by commits in the current branch but that are not in <upstream> are saved	to a temporary area. This is the same set of commits that would be shown by git log <upstream>..HEAD 	(or git log HEAD, if --root is specified).	The current branch is reset to <upstream>, or <newbase> if the --onto option was supplied. 	This has the exact same effect as git reset --hard <upstream> (or <newbase>). ORIG_HEAD is set 	to point at the tip of the branch before the reset.	The commits that were previously saved into the temporary area are then reapplied to the current branch,	one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit	in HEAD..<upstream> are omitted (i.e., a patch already accepted upstream with a different commit message	or timestamp will be skipped).	It is possible that a merge failure will prevent this process from being completely automatic.	You will have to resolve any such merge failure and run git rebase --continue. Another option is	to bypass the commit that caused the merge failure with git rebase --skip. To check out the original 	<branch> and remove the .git/rebase-apply working files, use the command git rebase --abort instead.	Assume the following history exists and the current branch is "topic":			  A---B---C topic			 /		D---E---F---G master	From this point, the result of either of the following commands:		git rebase master		git rebase master topic	would be:                  A'--B'--C' topic                 /    D---E---F---G master	NOTE: The latter form is just a short-hand of git checkout topic followed by git rebase master. 	When rebase exits topic will remain the checked-out branch.-------------------------------------------------------------------8)	What is cherry-picking in Git ?	Sometimes you have two branches b1 and b2, and you dont want to merge it,	BUT you NEED in b2 one commit from b1 , so 'cherry-pick' is very usefull.	It allows to get only one commit from another branch.		Syntax : git cherry-pick 3rk44             - get only one commit !!!				From documentation :		git cherry-pick - Apply the changes introduced by some existing commits			DESCRIPTION		Given one or more existing commits, apply the change each one introduces, recording a new		commit for each. This requires your working tree to be clean (no modifications from the HEAD commit).		When it is not obvious how to apply a change, the following happens:		The current branch and HEAD pointer stay at the last commit successfully made.		The CHERRY_PICK_HEAD ref is set to point at the commit that introduced the change that		is difficult to apply.		Paths in which the change applied cleanly are updated both in the index file and in your working tree.		For conflicting paths, the index file records up to three versions, as described in the "TRUE MERGE" section of git-merge(1). The working tree files will include a description of the conflict bracketed by the usual conflict markers <<<<<<< and >>>>>>>.		No other modifications are made.		See git-merge(1) for some hints on resolving such conflicts.	-------------------------------------------------------------------9)	Git create remote branches, and removing remote branches, describe. 	If you have more than one branches on local repo, you can easy push it to remote.	For example you have master branch, and v1.0_fixes branch.	To push 'v1.0_fixes' to remote do:		* git push origin v1.0_fixes			To list remote branches do :		* git branch -r			To delete remote branch do(it means push nothing to this branch):		* git push origin :v1.0_fixes-------------------------------------------------------------------
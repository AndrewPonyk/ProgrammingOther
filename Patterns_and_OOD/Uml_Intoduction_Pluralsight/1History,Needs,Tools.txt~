1) What is UML ? History of UML ? What are the TWO main types of DIAGRAMS in      UML (and their subtypes) ?Unified Modeling Language (UML) is a standardized (ISO/IEC 19501:2005), general-purpose  modeling language in the field of software engineering. The Unified Modeling Language includes a set of graphic notation techniques to create visual models of object-oriented software-intensive systems.  Unified Modeling Language (UML) combines techniques from data modeling  (entity relationship diagrams), business modeling (work flows), object      modeling, and component modeling. It can be used with all processes, throughout the software development life cycle, and across different implementation      technologies.   Before UML 1.x : After Rational Software Corporation hired James Rumbaugh from General Electric in 1994,  the company became the source for two of the most popular object-oriented modeling approaches of the day:[5]  Rumbaugh's  Object-modeling technique (OMT) and Grady Booch's method known as  Object-oriented design (OOD).  They were soon assisted in their efforts by  Ivar Jacobson, the creator of the  object-oriented software engineering (OOSE)      method. Jacobson joined Rational in 1995,  after his company, Objectory AB,[6] was      acquired by Rational. The three methodologists  were collectively referred to as the  <B>Three      Amigos</B>.    UML 1 - was accepted in 1997  UML 2 - wass accepted in 2005    There are FOUR parts to the UML 2.x specification:  1The Superstructure that defines the notation and semantics for diagrams and      their model elements  2The Infrastructure that defines the core metamodel on which the      Superstructure is based  3The Object Constraint Language (OCL) for defining rules for model elements  4The UML Diagram Interchange that defines how UML 2 diagram layouts are      exchanged     !!! The current versions of these standards follow: UML Superstructure version      2.4.1,   UML Infrastructure version 2.4.1, OCL version 2.3.1, and UML Diagram      Interchange version 1.0.  UML 2.2 has 14 types of diagrams divided into two categories.  Seven diagram types represent structural  information, and the other seven  represent general types of behavior,  including four that represent different  aspects of interactions.  These diagrams can be categorized hierarchically     Structure diagrams Structure diagrams emphasize the things that must be present in the system      being modeled. Since structure diagrams represent the structure, they are   used extensively in documenting the software architecture of software      systems. 1 Class diagram: describes the structure of a system by showing the system's      classes, their attributes, and the relationships among the classes. 2 Component diagram: describes how a software system is split up into      components and shows the dependencies among these components.  3 Composite structure diagram: describes the internal structure of a class and      the collaborations that this structure makes possible.  4 Deployment diagram: describes the hardware used in system implementations      and the execution environments and artifacts deployed on the hardware.  5 Object diagram: shows a complete or partial view of the structure of an      example modeled system at a specific time.  6 Package diagram: describes how a system is split up into logical groupings      by showing the dependencies among these groupings. 7 Profile diagram: operates at the metamodel level to show stereotypes as      classes with the <<stereotype>> stereotype, and profiles as packages with      the <<profile>> stereotype. The extension relation (solid line with      closed, filled arrowhead) indicates what metamodel element a given      stereotype is extending.     Behavior diagrams  Behavior diagrams emphasize what must happen in the system being modeled. Since behavior diagrams illustrate  the behavior of a system, they are used      extensively to describe the functionality of software systems. 1 Activity diagram: describes the business and operational step-by-step      workflows of components in a system. An activity diagram shows the overall      flow of control. 2 UML state machine diagram: describes the states and state transitions of the      system. 3 Use Case Diagram: describes the functionality provided by a system in terms   of actors, their goals represented as use cases, and any dependencies      among those use cases. Interaction diagrams 4 Interaction diagrams, a subset of behavior diagrams, emphasize the flow of      control and data among the things in the system being modeled: 4.1 Communication diagram: shows the interactions between objects or parts in      terms of sequenced messages. They represent a combination of information      taken from Class, Sequence, and Use Case Diagrams describing both the      static structure and dynamic behavior of a system. 4.2 Interaction overview diagram: provides an overview in which the nodes      represent communication diagrams. 4.3 Sequence diagram: shows how objects communicate with each other in terms      of a sequence of messages. Also indicates the lifespans of objects      relative to those messages. 4.4 Timing diagrams: a specific type of interaction diagram where the focus is      on timing constraints   ----------------------------------------------------------------------------------------2) Is UML Practical ?In a sufficiently complex system there are some places where some UML is considered useful.The useful diagrams for a system, vary by applicability. But the most widely used ones are State Diagrams, Activity Diagrams and Sequence Diagram.There are many enterprises who swear by them and many who outright reject them as an utter waste of time and effort.Its best not to go overboard and think whats best for the project you are on and pick the stuff that is applicable and makes sense.----------------------------------------------------------------------------------------3) Is UML a programming language?Short answer: no. Some UML modeling tools can generate Java, C++, and code in other programming languages. However, what it generates are usually interfaces and class relationships. These tools generate stubs for which the implementation still needs to be provided, so human intervention is necessary.----------------------------------------------------------------------------------------4)----------------------------------------------------------------------------------------5)----------------------------------------------------------------------------------------6)----------------------------------------------------------------------------------------